{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/MOVIES/New%20folder/K/kimi/src/prefetch.js"],"sourcesContent":["// A universal, runtime-based preloader for internal links.\r\n// This script is framework-agnostic and can be dropped into any modern web project.\r\n\r\n(function () {\r\n    // Ensure we're in a browser environment.\r\n    if (typeof window === 'undefined' || typeof document === 'undefined') {\r\n        return;\r\n    }\r\n\r\n    // --- Configuration ---\r\n    const PREFETCH_THROTTLE_MS = 500;\r\n    const IDLE_CALLBACK_TIMEOUT = 2000;\r\n\r\n    // --- State ---\r\n    const prefetched = new Set();\r\n    let activePrefetches = 0;\r\n    let scanTimeout;\r\n\r\n    // --- Global Stats for DevTools ---\r\n    window.__prefetchStats = {\r\n        total: 0,\r\n        queued: 0,\r\n        saved: 0,\r\n    };\r\n\r\n    // --- Utility Functions ---\r\n\r\n    /**\r\n     * Determines the max number of concurrent prefetches based on network conditions.\r\n     * @returns {number} The limit for parallel prefetches.\r\n     */\r\n    const getPrefetchLimit = () => {\r\n        const connection = navigator.connection;\r\n        if (connection?.saveData) return 0;\r\n        switch (connection?.effectiveType) {\r\n            case 'slow-2g':\r\n            case '2g':\r\n                return 2;\r\n            case '3g':\r\n                return 4;\r\n            case '4g':\r\n            default:\r\n                return 6;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Creates and manages a <link rel=\"prefetch\"> tag.\r\n     * @param {string} url - The URL to prefetch.\r\n     */\r\n    const prefetchUrl = (url) => {\r\n        if (prefetched.has(url) || activePrefetches >= getPrefetchLimit()) {\r\n            return;\r\n        }\r\n\r\n        activePrefetches++;\r\n        prefetched.add(url);\r\n        window.__prefetchStats.queued++;\r\n\r\n        const link = document.createElement('link');\r\n        link.rel = 'prefetch';\r\n        link.href = url;\r\n        link.as = 'document';\r\n\r\n        const onFinish = () => {\r\n            link.remove();\r\n            activePrefetches--;\r\n            window.__prefetchStats.total++;\r\n        };\r\n\r\n        link.addEventListener('load', onFinish);\r\n        link.addEventListener('error', onFinish);\r\n\r\n        document.head.appendChild(link);\r\n    };\r\n\r\n    /**\r\n     * The callback for the IntersectionObserver.\r\n     * @param {IntersectionObserverEntry[]} entries - The observed entries.\r\n     */\r\n    const observerCallback = (entries) => {\r\n        entries.forEach(entry => {\r\n            if (entry.isIntersecting && entry.target instanceof HTMLAnchorElement) {\r\n                const { href } = entry.target;\r\n                // Prefetch on idle to avoid blocking rendering.\r\n                requestIdleCallback(() => {\r\n                    prefetchUrl(href);\r\n                }, { timeout: IDLE_CALLBACK_TIMEOUT });\r\n            }\r\n        });\r\n    };\r\n\r\n    // --- Observers ---\r\n    const intersectionObserver = new IntersectionObserver(observerCallback, {\r\n        rootMargin: '50%', // Prefetch links 50% of the viewport height away.\r\n    });\r\n\r\n    const mutationObserver = new MutationObserver(() => {\r\n        // Throttle scanning to avoid performance issues on rapid DOM changes.\r\n        if (scanTimeout) clearTimeout(scanTimeout);\r\n        scanTimeout = setTimeout(scanForLinks, PREFETCH_THROTTLE_MS);\r\n    });\r\n\r\n    /**\r\n     * Scans the document for new, valid, internal links and observes them.\r\n     */\r\n    const scanForLinks = () => {\r\n        document.querySelectorAll('a').forEach(link => {\r\n            const url = new URL(link.href, document.location.origin);\r\n\r\n            // Rule: Must be an internal route (same origin).\r\n            if (location.origin !== url.origin) return;\r\n            // Rule: Not already prefetched.\r\n            if (prefetched.has(url.href)) return;\r\n            // Rule: Not a hash link, mailto, etc.\r\n            if (url.protocol !== 'http:' && url.protocol !== 'https:') return;\r\n            // Rule: Don't prefetch the current page.\r\n            if (url.pathname === location.pathname) return;\r\n\r\n            intersectionObserver.observe(link);\r\n        });\r\n    };\r\n\r\n    // --- History Wrapper ---\r\n\r\n    /**\r\n     * Wraps history methods to trigger a re-scan on SPA navigation.\r\n     * @param {('pushState'|'replaceState')} method - The history method to wrap.\r\n     */\r\n    const wrapHistoryMethod = (method) => {\r\n        const original = history[method];\r\n        history[method] = function (...args) {\r\n            const result = original.apply(this, args);\r\n            // Trigger a re-scan after the state has been changed.\r\n            requestAnimationFrame(scanForLinks);\r\n            return result;\r\n        };\r\n    };\r\n\r\n    // --- Initialization ---\r\n\r\n    /**\r\n     * Sets up all the observers and initial scan.\r\n     */\r\n    const initialize = () => {\r\n        // Don't run preloader if user prefers reduced data usage.\r\n        const connection = navigator.connection;\r\n        if (connection?.saveData) {\r\n            window.__prefetchStats.saved = 1;\r\n            return;\r\n        }\r\n\r\n        // Wrap history methods for SPA navigation detection.\r\n        wrapHistoryMethod('pushState');\r\n        wrapHistoryMethod('replaceState');\r\n\r\n        // Start observing the whole document for changes.\r\n        mutationObserver.observe(document.body, { childList: true, subtree: true });\r\n\r\n        // Perform the initial scan for links.\r\n        scanForLinks();\r\n    };\r\n\r\n    // Start the process once the document is ready.\r\n    if (document.readyState === 'loading') {\r\n        document.addEventListener('DOMContentLoaded', initialize);\r\n    } else {\r\n        initialize();\r\n    }\r\n\r\n})();\r\n"],"names":[],"mappings":"AAAA,2DAA2D;AAC3D,oFAAoF;;AAEpF,CAAC;IACG,yCAAyC;IACzC,wCAAsE;QAClE;IACJ;;;IAEA,wBAAwB;IACxB,MAAM;IACN,MAAM;IAEN,gBAAgB;IAChB,MAAM;IACN,IAAI;IACJ,IAAI;IASJ,4BAA4B;IAE5B;;;KAGC,GACD,MAAM;IAeN;;;KAGC,GACD,MAAM;IA0BN;;;KAGC,GACD,MAAM;IAYN,oBAAoB;IACpB,MAAM;IAIN,MAAM;IAMN;;KAEC,GACD,MAAM;IAiBN,0BAA0B;IAE1B;;;KAGC,GACD,MAAM;IAUN,yBAAyB;IAEzB;;KAEC,GACD,MAAM;AA0BV,CAAC"}}]
}